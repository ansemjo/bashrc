# distro info
alias distro='uname -nrmo && lsb_release -dc 2> /dev/null'

# enable color support of ls and also add handy aliases
if [ -x /usr/bin/dircolors ]; then
	test -r ~/.dircolors && eval "$(dircolors -b ~/.dircolors)" || eval "$(dircolors -b)"

	alias ls='ls --color=auto --group-directories-first'
	alias dir='dir --color=auto'
	alias vdir='vdir --color=auto'

	alias grep='grep --color=auto'
	alias fgrep='fgrep --color=auto'
	alias egrep='egrep --color=auto'
fi

# some ls aliases
alias l='ls -1F'	# one file per line
alias ll='ls -lF'	# long, classify
alias lla='ls -alF'	# all, long, classify; pretty verbose
alias la='ls -AF'	# almost all; like ls, but with .dot
alias lll='ls -lhARF'	# dirlist, generates huge output for many subfolders!

# display human-readable filesystem sizes
alias dfh='df -h'

# Directory navigation aliases
alias ..='cd ..'
alias ...='cd ../..'
alias ....='cd ../../..'
alias .....='cd ../../../..'
alias :q='exit'

# safety!
# makes these commands interactive,
# i.e. prevents accidental overwrites
alias rm='rm -i'
alias mv='mv -i'
alias cp='cp -i'
alias rmrf='rm -rf' # read mail really fast :)

# create in-place copy.bak quickly
bak() { cp --archive "$(echo "$1" | sed 's|[/]*$||')"{,.bak}; }

# some sudo shorthands
alias sudo='sudo '          # check command after sudo for aliases too
alias si='sudo vi'			# root vim editor
alias sedit='gksudo gedit' # launch gedit with root privileges
alias suu='sudo su'			# become root
alias runlevel='sudo /sbin/init'	# change current runlevel
alias chownr='sudo chown -R'		# recursive chown
alias chmodr='sudo chmod -R'		# recursive chmod
grab() {
  sudo chown -R ${USER} ${1:-.}		# grab ownership
}

chmod-files-recursive() { find . -type f -exec chmod "$1" {} \;; }
chmod-dirs-recursive()  { find . -type d -exec chmod "$1" {} \;; }

# powerdown aliases
alias shutdown!='sudo shutdown -P now'
alias reboot!='sudo reboot -f'

# some standards for slurm
if [ -x /usr/bin/slurm ]; then
  alias ifslurm='slurm -s -t foo -i eth0'
fi

# some fun with cmatrix
if [ -x /usr/bin/cmatrix ]; then
  alias matrix='cmatrix -ab -u2 -C green'
fi

# for when you quickly want to
# output a file with linenumbers
alias can='cat -sn'

# 'zero' the screen
alias 00='clear'

# various grep shorthands
alias igrep='egrep -i'
alias hh='history | igrep '
alias ff='find . | igrep '
alias psgrep='ps aux | igrep '
alias lgrep='l | igrep '
alias dpkgrep='dpkg --list | igrep '

# update and then show upgrades
if [ -x /usr/bin/apt ]; then
    alias upgrades='apt update && echo "------" && apt list --upgradable'
elif [ -x /usr/bin/pacman ]; then
    alias upgrades='pacman -Sy && echo "------" && pacman -Qu'
fi

# screen orientation, mainly intended for use on a laptop
if [ -x /usr/bin/xrandr ]; then
  alias ori='xrandr -o'
  alias orio='xrandr -o normal'
fi

# open nautilus here (if system is gnome)
if [ -x /usr/bin/nautilus ]; then
  alias here='nautilus -w --no-desktop `pwd` &> /dev/null &'
fi

# output random characters from urandom
randomchar () {
    case $1 in
        ''|*[!0-9]*) AMM=32 ;;
        *) AMM=$1 ;;
    esac
    < /dev/urandom tr -dc _A-Z-a-z-0-9 | head -c${1:-$AMM};echo;
}

# colorful diff if installed
if command -v colordiff &>/dev/null; then
    alias diff='colordiff'
fi

# watch with exit
if command -v watch &>/dev/null; then
    alias watcherr='watch -ebn 10 "$@"'
fi

# weather forecast
alias weather='curl wttr.in'

## some larger functions below
#################################################################

# make and enter
mkcd () {
  if [ ! -n "$1" ]; then
    echo "Enter a directory name"
  elif [ -d $1 ]; then
    echo "'$1' already exists"
  else
    mkdir $1 && cd $1
  fi
}

# make and enter a temporary directory
mkcdtmp () {
    cd $(mktemp -d) && pwd
}

# extraction function
extract () {
  if [ -f $1 ] ; then
    case $1 in
	*.tar.bz2)   tar xjf $1		;;
	*.tar.gz)    tar xzf $1		;;
	*.bz2)       bunzip2 $1		;;
	*.rar)       rar x $1		;;
	*.gz)        gunzip $1		;;
	*.tar)       tar xf $1		;;
	*.tbz2)      tar xjf $1		;;
	*.tgz)       tar xzf $1		;;
	*.zip)       unzip $1		;;
	*.Z)         uncompress $1	;;
	*.7z)        7z x $1		;;
	*)           echo "'$1' cannot be extracted via extract()" ;;
    esac
  else
    echo "'$1' is not a valid file"
  fi
}

#netinfo - shows network information for your system
ipaddr ()
{
 _grep="^[[:digit:]]\+:\|^[[:space:]]*\(link/\|inet\)"

 _mac="[a-f0-9:]*"
 _ipv4s="[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\/[0-9]\{1,3\}"
 _ipv6s="$_mac\/[0-9]\{1,3\}"

 _iface="s/^[[:digit:]]\+: \(.*\): <.*> .* state \(UP\|DOWN\|UNKNOWN\).*$/\n\1 (\2):/"
 _link="s/link\/\(.* $_mac\) .*$/\1/"
 _inet4="s/inet \($_ipv4s\) .*$/ipv4 \1/"
 _inet6="s/inet6 \($_ipv6s\) .*$/ipv6 \1/"

 ip addr | grep -e "$_grep" | sed -e "$_iface" -e "$_link" -e "$_inet4" -e "$_inet6"

 if command -v curl &>/dev/null && command -v publicip &>/dev/null; then
   echo -e "\n"
   publicip
 fi
 echo
}

# get public ip addr with wtfismyip.com
publicip() {
    echo -n "public ipv4: "; curl -s https://ipv4.wtfismyip.com/text || echo "error. no ipv4?"
    echo -n "public ipv6: "; curl -s https://ipv6.wtfismyip.com/text || echo "error. no ipv6?"
}

#dirsize - finds directory sizes and lists them for the current directory
dirsize ()
{
 du -shx * .[a-zA-Z0-9_]* 2> /dev/null | \
 egrep '^ *[0-9.]*[MG]' | sort -n > /tmp/list
 egrep '^ *[0-9.]*M' /tmp/list
 egrep '^ *[0-9.]*G' /tmp/list
 rm -rf /tmp/list
}

# pingscan, preferably show all active IPs on local network
pingscan ()
{
if [ $1 ] ; then
 nmap -sn $1 | grep report | sed -e 's/Nmap scan report for //'
else
 echo "please specify a subnet, like so:   pingscan 192.168.0.*"
fi
}

# led control on the usb armory
led ()
{
  if [ $1 ] ; then
    LED="/sys/class/leds/LED/brightness"
    case $1 in
       manual)	modprobe -r ledtrig-heartbeat	;;
       heart)	modprobe ledtrig-heartbeat	;;
       1)	echo 0 > $LED ;;
       on)	echo 0 > $LED ;;
       0)	echo 1 > $LED ;;
       off)	echo 1 > $LED ;;
       *)	echo "use: 0/off or 1/on as argument, when on manual. otherwise use heart or manual to switch the mode"	;;
    esac
  else
    echo "use: 0/off or 1/on as argument"
  fi
}

# if true loop
whiletrue ()
{
  while true; do "$@"; sleep 1; clear; done;
}

# wait for any keypress
waitkey ()
{
  read -rsp $'Press any key to continue...\n' -n1 key
}

# print color table
colors() {
    local fgc bgc vals seq0

    printf "Color escapes are %s\n" '\e[${value};...;${value}m'
    printf "Values 30..37 are \e[33mforeground colors\e[m\n"
    printf "Values 40..47 are \e[43mbackground colors\e[m\n"
    printf "Value  1 gives a  \e[1mbold-faced look\e[m\n  i.e. \\\e[1;30m \n\n"

    # foreground colors
    for fgc in {30..37}; do
        # background colors
        for bgc in {40..47}; do
            fgc=${fgc#37} # white
            bgc=${bgc#40} # black

            vals="${fgc:+$fgc;}${bgc}"
            vals=${vals%%;}

            seq0="${vals:+\e[${vals}m}"
            printf "  %-9s" "${seq0:-(default)}"
            printf " ${seq0}TEXT\e[m"
            printf " \e[${vals:+${vals+$vals;}}1mBOLD\e[m\n"
        done
        echo; echo
    done
}

# read markdown files
if [ -x /usr/bin/pandoc ]; then
markman() {
    pandoc -s -f markdown -t man "$1" | man -l -
}; fi

# pipe files with tar via ssh
tarpipe() {
mode="$1"; shift
pipe="/tmp/.tarpipe"
usage="Usage:
 tarpipe receive[r] \$host     #note: reveiveR loops
 tarpipe fetch \$host \$files  #note: uses sudo!
 tarpipe send \$files"

case "$mode" in
    receive|receiver )
        test -n "$1" && host="$1" && shift || { echo "$usage"; return 1; }
        test "$mode" = "receiver" && echo "RECEIVER .. (loop, CTRL-C to exit ..)" || echo "RECEIVE"
        while true; do
            ssh $host "test -e $pipe && rm -f $pipe; mkfifo $pipe; cat $pipe; rm $pipe" 2>/dev/null |\
              tar xvkf - --xform s:^.*/::
            test "$mode" = "receiver" || break
        done ;;

    send )
        test -n "$1" || { echo "$usage"; return 1; }
        echo "SENDER ..."
        while test ! -e $pipe; do echo "no receiver present ... waiting ..."; sleep 5; done
        tar cv --xform s:^.*/:: -f $pipe $@;;

    fetch )
        test -n "$1" && host="$1" && shift || { echo "$usage"; return 1; }
        test -n "$1" || { echo "$usage"; exit 1; }
        echo "FETCHING ..."
        (ssh $host "test -e $pipe && rm -f $pipe; mkfifo $pipe; cat $pipe; rm $pipe" 2>/dev/null |\
          tar xkf - )&
        ssh -t $host "sudo tar cv --xform s:^.*/:: -f $pipe $@" ;;

    * )
        echo "$usage"; return 1;;
esac
}

if [ -x /usr/bin/rankmirrors ]; then
update-mirrorlist() {
    mirrors="/etc/pacman.d/mirrorlist"
    # select mirrors source file
    echo "--> selecting source file .."
    if [ -n "$1" ]; then
        # specified on cmdline
        if [ ! -f "$1" ]; then
            echo "--> no file '$1' exists"
            return 2
        fi
        source="$1"
    else
        # use mirrorlist.pacnew
        pacnew="${mirrors}.pacnew"
        if [ ! -f $pacnew ]; then
            echo "--> no source file specified and no mirrorlist.pacnew available"
            return 2
        fi
        source=$pacnew
    fi
    echo "--> using $source"
    # uncomment all Servers
    echo "--> uncomment any Servers in source file"
    sudo sed -i 's/^#Server/Server/' "$source"
    # run rankmirrors
    echo "--> running rankmirrors ..."
    rankmirrors -n 15 "$source" | sudo tee $mirrors
}
fi

### OpenSSL shortcuts taken from: https://certsimple.com/blog/openssl-shortcuts
### Supplemented with some info from https://www.phildev.net/ssl/managing_ca.html

# view
alias openssl-view-cert='openssl x509 -text -noout -in'
alias openssl-view-request='openssl req -text -noout -verify -in'
alias openssl-view-revocationlist='openssl crl -noout -text -in'
alias openssl-view-key='openssl rsa -check -in'
alias openssl-view-pkcs12='openssl pkcs12 -info -in'
alias openssl-client='openssl s_client -status -connect'

openssl-check-modulus-cert() { openssl x509 -noout -modulus -in "${1}" | shasum -a 256; }
openssl-check-modulus-rsakey() { openssl rsa -noout -modulus -in "${1}" | shasum -a 256; }
openssl-check-modulus-request() { openssl req -noout -modulus -in "${1}" | shasum -a 256; }
openssl-file-encrypt() { openssl aes-256-cbc -in "${1}" -out "${2}"; }
openssl-file-decrypt() { openssl aes-256-cbc -d -in "${1}" -out "${2}"; }

openssl-help() { echo -e "
openssl req -new [-newkey rsa:....] [-nodes] -keyout KEY -out CSR
openssl ca [-create_serial -selfsign] [-extensions ...] [-days ...] -in CSR
openssl verify [-CAfile CACRT] -in CRT
"; }

openssl-install-ca() { ln -s "$1" "$(openssl x509 -hash -noout -in "$1").0"; }

# Convert PEM private key, PEM certificate and PEM CA certificate (used by nginx, Apache, and other openssl apps) to a PKCS12 file (typically for use with Windows or Tomcat)
openssl-convert-pem-to-p12() {
    test -n "$1" -a -n "$2" -a -n "$3" -a -n "$4" ||\
        { echo "\$1:key \$2:cert \$3:cacert \$4:out"; return 1; }
    openssl pkcs12 -export -inkey "${1}" -in "${2}" -certfile "${3}" -out "${4}"; }
openssl-convert-p12-to-pem() {
    test -n "$1" -a -n "$2" ||\
        { echo "\$1:p12-in \$2:out"; return 1; }
    openssl pkcs12 -nodes -in "${1}" -out "${2}"; }
