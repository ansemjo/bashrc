# distro info
alias distro='uname -nrmo && lsb_release -dc 2> /dev/null'

# enable color support of ls and also add handy aliases
if [ -x /usr/bin/dircolors ]; then
	test -r ~/.dircolors && eval "$(dircolors -b ~/.dircolors)" || eval "$(dircolors -b)"

	alias ls='ls --color=auto --group-directories-first'
	alias dir='dir --color=auto'
	alias vdir='vdir --color=auto'

	alias grep='grep --color=auto'
	alias fgrep='fgrep --color=auto'
	alias egrep='egrep --color=auto'
fi

# some ls aliases
alias l='ls -1F'	# one file per line
alias ll='ls -lF'	# long, classify
alias lla='ls -alF'	# all, long, classify; pretty verbose
alias la='ls -AF'	# almost all; like ls, but with .dot
alias lll='ls -lhARF'	# dirlist, generates huge output for many subfolders!

# display human-readable filesystem sizes
alias dfh='df -h'

# Directory navigation aliases
alias ..='cd ..'
alias ...='cd ../..'
alias ....='cd ../../..'
alias .....='cd ../../../..'
alias :q='exit'

# safety!
# makes these commands interactive,
# i.e. prevents accidental overwrites
alias rm='rm -i'
alias mv='mv -i'
alias cp='cp -i'
alias rmrf='rm -rf' # read mail really fast :)

# create in-place copy.bak quickly
bak() { cp --archive "$1"{,.bak}; }

# some sudo shorthands
alias si='sudo vi'			# root vim editor
alias sedit='gksudo gedit' # launch gedit with root privileges
alias suu='sudo su'			# become root
alias runlevel='sudo /sbin/init'	# change current runlevel
alias chownr='sudo chown -R'		# recursive chown
alias chmodr='sudo chmod -R'		# recursive chmod
grab() {
  sudo chown -R ${USER} ${1:-.}		# grab ownership
}

# powerdown aliases
alias shutdown!='sudo shutdown -P now'
alias reboot!='sudo reboot -f'

# some standards for slurm
if [ -x /usr/bin/slurm ]; then
  alias ifslurm='slurm -s -t foo -i eth0'
fi

# some fun with cmatrix
if [ -x /usr/bin/cmatrix ]; then
  alias matrix='cmatrix -ab -u2 -C green'
fi

# for when you quickly want to
# output a file with linenumbers
alias can='cat -sn'

# 'zero' the screen
alias 00='clear'

# various grep shorthands
alias igrep='egrep -i'
alias hh='history | igrep '
alias ff='find . | igrep '
alias psgrep='ps aux | igrep '
alias lgrep='l | igrep '
alias dpkgrep='dpkg --list | igrep '

# screen orientation, mainly intended for use on a laptop
if [ -x /usr/bin/xrandr ]; then
  alias ori='xrandr -o'
  alias orio='xrandr -o normal'
fi

# open nautilus here (if system is gnome)
if [ -x /usr/bin/nautilus ]; then
  alias here='nautilus -w --no-desktop `pwd` &> /dev/null &'
fi

# output random characters from urandom
randomchar () {
    case $1 in
        ''|*[!0-9]*) AMM=32 ;;
        *) AMM=$1 ;;
    esac
    < /dev/urandom tr -dc _A-Z-a-z-0-9 | head -c${1:-$AMM};echo;
}

# colorful diff if installed
if command -v colordiff &>/dev/null; then
    alias diff='colordiff'
fi

# watch with exit
if command -v watch &>/dev/null; then
    alias watcherr='watch -ebn 10 "$@"'
fi

## some larger functions below
#################################################################

# make and enter
mkcd () {
  if [ ! -n "$1" ]; then
    echo "Enter a directory name"
  elif [ -d $1 ]; then
    echo "'$1' already exists"
  else
    mkdir $1 && cd $1
  fi
}

# make and enter a temporary directory
mkcdtmp () {
    cd $(mktemp -d) && pwd
}

# extraction function
extract () {
  if [ -f $1 ] ; then
    case $1 in
	*.tar.bz2)   tar xjf $1		;;
	*.tar.gz)    tar xzf $1		;;
	*.bz2)       bunzip2 $1		;;
	*.rar)       rar x $1		;;
	*.gz)        gunzip $1		;;
	*.tar)       tar xf $1		;;
	*.tbz2)      tar xjf $1		;;
	*.tgz)       tar xzf $1		;;
	*.zip)       unzip $1		;;
	*.Z)         uncompress $1	;;
	*.7z)        7z x $1		;;
	*)           echo "'$1' cannot be extracted via extract()" ;;
    esac
  else
    echo "'$1' is not a valid file"
  fi
}

#netinfo - shows network information for your system
ipaddr ()
{
 _grep="^[[:digit:]]\+:\|^[[:space:]]*\(link/\|inet\)"

 _mac="[a-f0-9:]*"
 _ipv4s="[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\/[0-9]\{1,3\}"
 _ipv6s="$_mac\/[0-9]\{1,3\}"

 _iface="s/^[[:digit:]]\+: \(.*\): <.*> .* state \(UP\|DOWN\|UNKNOWN\).*$/\n\1 (\2):/"
 _link="s/link\/\(.* $_mac\) .*$/\1/"
 _inet4="s/inet \($_ipv4s\) .*$/ipv4 \1/"
 _inet6="s/inet6 \($_ipv6s\) .*$/ipv6 \1/"

 ip addr | grep -e "$_grep" | sed -e "$_iface" -e "$_link" -e "$_inet4" -e "$_inet6"

 if command -v curl &>/dev/null && command -v publicip &>/dev/null; then
   echo -e "\n"
   publicip
 fi
 echo
}

# get public ip addr with wtfismyip.com
publicip() {
    echo -n "public ipv4: "; curl -s https://ipv4.wtfismyip.com/text || echo "error. no ipv4?"
    echo -n "public ipv6: "; curl -s https://ipv6.wtfismyip.com/text || echo "error. no ipv6?"
}

#dirsize - finds directory sizes and lists them for the current directory
dirsize ()
{
 du -shx * .[a-zA-Z0-9_]* 2> /dev/null | \
 egrep '^ *[0-9.]*[MG]' | sort -n > /tmp/list
 egrep '^ *[0-9.]*M' /tmp/list
 egrep '^ *[0-9.]*G' /tmp/list
 rm -rf /tmp/list
}

# pingscan, preferably show all active IPs on local network
pingscan ()
{
if [ $1 ] ; then
 nmap -sn $1 | grep report | sed -e 's/Nmap scan report for //'
else
 echo "please specify a subnet, like so:   pingscan 192.168.0.*"
fi
}

# led control on the usb armory
led ()
{
  if [ $1 ] ; then
    LED="/sys/class/leds/LED/brightness"
    case $1 in
       manual)	modprobe -r ledtrig-heartbeat	;;
       heart)	modprobe ledtrig-heartbeat	;;
       1)	echo 0 > $LED ;;
       on)	echo 0 > $LED ;;
       0)	echo 1 > $LED ;;
       off)	echo 1 > $LED ;;
       *)	echo "use: 0/off or 1/on as argument, when on manual. otherwise use heart or manual to switch the mode"	;;
    esac
  else
    echo "use: 0/off or 1/on as argument"
  fi
}

# if true loop
whiletrue ()
{
  while true; do "$@"; sleep 1; clear; done;
}

# wait for any keypress
waitkey ()
{
  read -rsp $'Press any key to continue...\n' -n1 key
}

# print color table
colors() {
    local fgc bgc vals seq0

    printf "Color escapes are %s\n" '\e[${value};...;${value}m'
    printf "Values 30..37 are \e[33mforeground colors\e[m\n"
    printf "Values 40..47 are \e[43mbackground colors\e[m\n"
    printf "Value  1 gives a  \e[1mbold-faced look\e[m\n  i.e. \\\e[1;30m \n\n"

    # foreground colors
    for fgc in {30..37}; do
        # background colors
        for bgc in {40..47}; do
            fgc=${fgc#37} # white
            bgc=${bgc#40} # black

            vals="${fgc:+$fgc;}${bgc}"
            vals=${vals%%;}

            seq0="${vals:+\e[${vals}m}"
            printf "  %-9s" "${seq0:-(default)}"
            printf " ${seq0}TEXT\e[m"
            printf " \e[${vals:+${vals+$vals;}}1mBOLD\e[m\n"
        done
        echo; echo
    done
}

# read markdown files
if [ -x /usr/bin/pandoc ]; then
markman() {
    pandoc -s -f markdown -t man "$1" | man -l -
}; fi


### OpenSSL shortcuts taken from: https://certsimple.com/blog/openssl-shortcuts

# view
function openssl-view-certificate () { openssl x509 -text -noout -in "${1}"; }
function openssl-view-csr () { openssl req -text -noout -verify -in "${1}"; }
function openssl-view-key () { openssl rsa -check -in "${1}"; }
function openssl-view-pkcs12 () { openssl pkcs12 -info -in "${1}"; }
function openssl-client () { openssl s_client -status -connect "${1}":443; }

# check modulus
function openssl-check-certificate-modulus { openssl x509 -noout -modulus -in "${1}" | shasum -a 256; }
function openssl-check-key-modulus { openssl rsa -noout -modulus -in "${1}" | shasum -a 256; }
function openssl-check-csr-modulus { openssl req -noout -modulus -in "${1}" | shasum -a 256; }

# encrypt / decrypt
function openssl-encrypt () { openssl aes-256-cbc -in "${1}" -out "${2}"; }
function openssl-decrypt () { openssl aes-256-cbc -d -in "${1}" -out "${2}"; }

# convert
# Convert PEM private key, PEM certificate and PEM CA certificate (used by nginx, Apache, and other openssl apps) to a PKCS12 file (typically for use with Windows or Tomcat)
function openssl-convert-pem-to-p12 () { openssl pkcs12 -export -inkey "${1}" -in "${2}" -certfile "${3}" -out "${4}"; }
function openssl-convert-p12-to-pem () { openssl pkcs12 -nodes -in "${1}" -out "${2}"; }
